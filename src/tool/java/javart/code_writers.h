#pragma once

namespace xlang
{
    template <typename T>
    constexpr auto to_underlying(T const value) noexcept
    {
        return static_cast<std::underlying_type_t<T>>(value);
    }

    static void write_license(writer& w)
    {
        auto format = R"(// WARNING: Please don't edit this file. It was generated by javart v%
)";

        w.write(format, XLANG_VERSION_STRING);
    }

    static void write_jni_prolog(writer& w, std::string_view const& ns)
    {
        auto format = R"(// Java/WinRT projection for % namespace

#include "pch.h"
#include "javart.h"
#include <string_view>
#include "winrt/%.h"

using namespace std::literals;
using namespace winrt;

#define JNI_EXPORT_NAMESPACE %

)";

        w.write(format, ns, ns, java_export{ ns });
    }

    template<type_system system>
    static void write_param_as(writer& w, std::pair<Param, const ParamSig*> const& param, std::string_view const& format)
    {
        w.write_as(system, format, param.second->Type(), param.first.Name());
    }

    template<type_system system>
    static void write_param_type_as(writer& w, std::pair<Param, ParamSig const*> const& param)
    {
        w.write_as(system, param.second->Type());
    }

    template<type_system system>
    static void write_type_as(writer& w, TypeSig const& typeSig)
    {
        w.write_as(system, typeSig);
    }

    template<type_system system>
    static void write_return_type_as(writer& w, RetTypeSig const& typeSig)
    {
        if (!typeSig)
        {
            w.write("void");
            return;
        }
        w.write_as(system, typeSig.Type());
    }

    static void write_method_arg(writer& w, std::pair<Param, ParamSig const*> const& param)
    {
        w.write(param.first.Name());
    }

    enum class generic_interface_type
    {
        Iterable,
        VectorView,
        MapView,
        Vector,
        Map
    };

    static constexpr struct 
    {
        std::string_view interface_name;
        std::string_view base_class;
        std::string_view base_trait;
        std::string_view projected;
        std::string_view java_class;
    }
    generic_interface_info[] =
    {
        {"IIterable"sv, "Iterable"sv, "iterator_type"sv, "Iterator"sv, "java.lang.Iterable"},
        {"IVectorView"sv, "VectorView"sv, "vector_view_type"sv, "VectorView"sv, "java.lang.VectorView"},
        {"IMapView"sv, "MapView"sv, "map_view_type"sv, "MapView"sv, "java.lang.MapView"},
        {"IVector"sv, "Vector"sv, "vector_type"sv, "Vector"sv, "java.lang.Vector"},
        {"IMap"sv, "Map"sv, "map_type"sv, "Map"sv, "java.lang.Map"},
    };

    static auto get_interface_info(writer& w, TypeDef const& type)
    {
        std::map<std::variant<generic_interface_type, std::string>, interface_info> interfaces;

        for (auto&&[interface_name, info] : get_interfaces(w, type))
        {
            // TODO: some interfaces lack exclusiveto attribute (e.g., IWwwFormUrlDecoderEntry)
            // use naming convention to assume exclusiveto in theses cases, and avoid unnecessary projection.
            // Some::Namespace::IRuntimeClass is assumed to be exclusive to Some::Namespace::RuntimeClass.
            if (is_exclusive(info.type))
            {
                continue;
            }

            static constexpr std::string_view collections_namespace("Windows.Foundation.Collections."sv);
            if (starts_with(interface_name, collections_namespace))
            {
                [&]{
                    auto relative_type = interface_name.substr(collections_namespace.size());
                    for (int i = 0; i < _countof(generic_interface_info); ++i)
                    {
                        if (starts_with(relative_type, generic_interface_info[i].interface_name))
                        {
                            interfaces[static_cast<generic_interface_type>(i)] = std::move(info);
                            return;
                        }
                    }
                    XLANG_ASSERT(false);
                }();
            }
            else
            {
                interfaces[interface_name] = std::move(info);
            }
        };
        return interfaces;
    }

    static void write_jni_generic_base(writer& w, std::pair<std::variant<generic_interface_type, std::string>, interface_info> const& ifc, std::string_view const& derived_type)
    {
        if (auto generic_interface = std::get_if<generic_interface_type>(&ifc.first))
        {
            w.write(", %<%>", 
                generic_interface_info[to_underlying(*generic_interface)].base_class, 
                derived_type
            );
        }
    }

    static void write_jni_stub_iterator(writer& w, generic_iterator const& gi)
    {
        auto format = R"(struct % : Projection<Windows::Foundation::Collections::IIterator<%>>, Iterator<%>
{
	static constexpr char projected_type[] = "%";
	static constexpr char element_type[] = "%";

	static void Register(jni_env& env, jclass cls)
	{
		Projection::Register(env, cls);
		Iterator::Register(env, cls);
	}
};
JNI_EXPORT(%);

)";

        w.write(format,
            gi.name,
            gi.cpp_type,
            gi.name,
            java_type_name{ gi.name, w.type_namespace },
            gi.java_element,
            gi.name
        );
    }

    static void write_jni_generic_trait(writer& w, std::pair<std::variant<generic_interface_type, std::string>, interface_info> const& ifc)
    {
        if (auto generic_interface = std::get_if<generic_interface_type>(&ifc.first))
        {
            auto cpp_params = w.write_temp("%", bind_list(",", ifc.second.generic_param_stack.back()));
            auto params = cpp_params;
            auto is_delimiter = [](auto&& x) { return x == ':' || x == ','; };
            params.erase(std::remove_if(params.begin(), params.end(), is_delimiter), params.end());
            auto name = w.write_temp("%%", generic_interface_info[to_underlying(*generic_interface)].projected, params);

            if (*generic_interface == generic_interface_type::Iterable)
            {
                std::string element;
                for (auto it = cpp_params.begin(); it != cpp_params.end(); ++it)
                {
                    if (*it == ':')
                    {
                        element.append("/");
                        ++it;
                    }
                    else
                    {
                        element.append(1, *it);
                    }
                }
                w.add_iterator({ name, cpp_params, element });
            }

            auto format = R"(    static constexpr char %[] = "%";
)";
            w.write(format,
                generic_interface_info[to_underlying(*generic_interface)].base_trait,
                java_type_name{ name, w.type_namespace });
        }
    }

    static void write_jni_generic_register(writer& w, std::pair<std::variant<generic_interface_type, std::string>, interface_info> const& ifc)
    {
        if (auto generic_interface = std::get_if<generic_interface_type>(&ifc.first))
        {
            auto format = R"(        %::Register(env, cls);
)";
            w.write(format, 
                generic_interface_info[to_underlying(*generic_interface)].base_class
            );
        }
    }

    static void write_jni_method_arg(writer& w, std::pair<Param, ParamSig const*> const& param)
    {
        call(param.second->Type().Type(),
            [&](ElementType type)
        {
            if (type == ElementType::String)
            {
                w.write("jstring_view(env, %)", param.first.Name());
                return;
            }
            w.write(param.first.Name());
        },
            [&](coded_index<TypeDefOrRef> const& type)
        {
            w.write(type);
        },
            [&](GenericTypeIndex var)
        {
            w.write(var);
        },
            [&](auto&& type)
        {
            w.write(type);
        });
    }

    static void write_jni_constructor(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };

        auto format = R"(    static auto Construct%(jni_env& env, jclass%)
    {
        return create_agile_ref(type{%});
    }

)";
        auto&& params = signature.params();
        w.write(format,
            bind_each<write_param_type_as<java_suffix>>(params),
            bind_list<write_param_as<jni_type>>(", ", params, ", % %"),
            bind_list<write_jni_method_arg>(", ", params)
        );
    }

    static void write_jni_method(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };

        auto format = R"(    static auto abi_%(jni_env&, jobject, jlong abi%)
    {
        return resolve{ abi }.%(%);
    }
        
)";
        auto&& params = signature.params();
        w.write(format,
            method.Name(),
            bind_list<write_param_as<jni_type>>(", ", params, ", % %"),
            method.Name(),
            bind_list<write_jni_method_arg>(", ", params)
        );
    }

    struct push_interface_generic_params
    {
        explicit push_interface_generic_params(writer& writer, interface_info const& info)
            : writer_stack(writer.generic_param_stack), interface_stack(info.generic_param_stack)
        {
            writer_stack.insert(writer_stack.end(), interface_stack.begin(), interface_stack.end());
        }

        ~push_interface_generic_params()
        {
            writer_stack.resize(writer_stack.size() - interface_stack.size());
        }

        std::vector<std::vector<std::string>>& writer_stack;
        std::vector<std::vector<std::string>> const& interface_stack;
    };

    static void write_jni_methods(writer& w, std::pair<std::variant<generic_interface_type, std::string>, interface_info> const& ifc)
    {
        if (auto interface_name = std::get_if<std::string>(&ifc.first))
        {
            push_interface_generic_params params(w, ifc.second);
            w.write("%", bind_each<write_jni_method>(ifc.second.type.MethodList()));
        }
    }

    static void write_jni_constructor_registration(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };

        auto format = R"(            JNI_METHOD_(Construct%, "(%)J"),
)";
        auto&& params = signature.params();
        w.write(format,
            bind_each<write_param_type_as<java_suffix>>(params),
            bind_each<write_param_type_as<java_descriptor>>(signature.params())
        );
    }

    static void write_jni_method_registration(writer& w, MethodDef const& method)
    {
        method_signature signature{ method };

        auto format = R"(            JNI_METHOD_(abi_%, "(%)%"),
)";
        w.write(format,
            method.Name(),
            bind_each<write_param_type_as<java_descriptor>>(signature.params()),
            bind<write_return_type_as<java_descriptor>>(signature.return_signature())
        );
    }

    static void write_jni_method_registrations(writer& w, std::pair<std::variant<generic_interface_type, std::string>, interface_info> const& ifc)
    {
        if (auto interface_name = std::get_if<std::string>(&ifc.first))
        {
            push_interface_generic_params params(w, ifc.second);
            w.write("%", bind_each<write_jni_method_registration>(ifc.second.type.MethodList()));
        }
    }

    static void write_jni_stub_inspectable(writer& w)
    {
        auto format = R"(struct Inspectable : Projection<Windows::Foundation::IInspectable>
{
	static constexpr char projected_type[] = "Windows/Foundation/Inspectable";

    static auto abi_AddRef(jni_env&, jobject, jlong abi)
    {
        if (auto obj = agile_abi_ref::from(abi))
        {
            obj->addref();
        }
    }

    static auto abi_Release(jni_env&, jobject, jlong abi)
    {
        if (auto obj = agile_abi_ref::from(abi))
        {
            obj->release();
        }
    }

    static auto abi_GetClassName(jni_env&, jobject, jlong abi)
    {
        return get_class_name(resolve{ abi });
    }

    static auto abi_GetIdentity(jni_env&, jobject, jlong abi)
    {
        auto obj = resolve{ abi };
        return obj ? reinterpret_cast<jlong>(get_abi(obj.as<::IUnknown>())) : jlong{};
    }

    static void Register(jni_env& env, jclass cls) 
    {
        Projection::Register(env, cls);
        static JNINativeMethod methods[] =
        {
            JNI_METHOD_(abi_AddRef, "(J)V"),
            JNI_METHOD_(abi_Release, "(J)V"),
            JNI_METHOD_(abi_GetClassName, "(J)Ljava/lang/String;"),
            JNI_METHOD_(abi_GetIdentity, "(J)J"),
        };
        env.register_natives(cls, methods);
    }
};
JNI_EXPORT(Inspectable);

)";

        w.write(format);
    }

    static void write_jni_stub(writer& w, TypeDef const& type)
    {
        if (!settings.filter.includes(type))
        {
            return;
        }

        auto format = R"(struct % : Projection<@::%>%
{
    static constexpr char projected_type[] = "%";
%
%%    static void Register(jni_env& env, jclass cls)
    {
        Projection::Register(env, cls);
%        static JNINativeMethod methods[] =
        {
%%        };
        env.register_natives(cls, methods);
    }
};
JNI_EXPORT(%);

)";

        auto interfaces = get_interface_info(w, type);

        w.write(format, 
            type.TypeName(),
            type.TypeNamespace(),
            type.TypeName(),
            bind_each<write_jni_generic_base>(interfaces, type.TypeName()),
            java_type_name{ type },
            bind_each<write_jni_generic_trait>(interfaces),
            bind_each<write_jni_constructor>(get_constructors(type)),
            bind_each<write_jni_methods>(interfaces),
            bind_each<write_jni_generic_register>(interfaces),
            bind_each<write_jni_constructor_registration>(get_constructors(type)),
            bind_each<write_jni_method_registrations>(interfaces),
            type.TypeName()
            );
    }

    static bool is_foundation(std::string_view const& ns)
    {
        return ns == "Windows.Foundation";
    }

    static void write_jni_stubs_special(writer& w, std::string_view const& ns)
    {
        if (!is_foundation(ns))
        {
            return;
        }

        write_jni_stub_inspectable(w);
    }

    static void write_jni_stubs(writer& w, std::string_view const& ns, std::vector<TypeDef> const& classes)
    {
        write_jni_stubs_special(w, ns);
        w.write_each<write_jni_stub>(classes);
    }

    static void write_jni_unregister(writer& w, TypeDef const& type)
    {
        if (!settings.filter.includes(type))
        {
            return;
        }

        auto format = R"(    %::Unregister(*env);
)";

        w.write(format, type.TypeName());
    }

    static void write_jni_unregister_special(writer& w, std::string_view const& ns)
    {
        if (!is_foundation(ns))
        {
            return;
        }

        auto format = R"(    Inspectable::Unregister(env);
)";

        w.write(format);
    }

    static void write_jni_unregisters(writer& w, std::string_view const& ns, std::vector<TypeDef> const& classes)
    {
        auto format = R"(void %_Unregister(jni_env& env)
{
%%}
)";

        w.write(format,
            java_export{ ns },
            bind_each<write_jni_unregister>(classes),
            bind<write_jni_unregister_special>(ns)
            );
    }

    static void write_java_implements(writer& w, std::map<std::variant<generic_interface_type, std::string>, interface_info> const& ifcs)
    {
        auto is_first{true};

        for (auto&&[key, info] : ifcs)
        {
            if (is_exclusive(info.type))
            {
                continue;
            }
            auto write_implements = [&](auto&& implements)
            {
                if (is_first)
                {
                    is_first = false;
                    w.write("implements %", implements);
                    return;
                }
                w.write(", %", implements);
            };

            if (auto generic_interface = std::get_if<generic_interface_type>(&key))
            {
                auto params = w.write_temp("%", bind_list(",", info.generic_param_stack.back()));
                auto implements = std::string(generic_interface_info[to_underlying(*generic_interface)].java_class) + "<" + params + ">";
                write_implements(params);
            }
            else
            {
                write_implements(std::get<std::string>(key));
            }
        }
    }

    static void write_java_constructor(writer& w, MethodDef const& method, TypeDef const& type)
    {
        method_signature signature{ method };
        
        auto format = R"(    public %(%) {
        this(Construct%(%));
    }

)";

        w.write(format,
            type.TypeName(),
            bind_list<write_param_as<java_type>>(", ", signature.params(), "% %"),
            bind_each<write_param_type_as<java_suffix>>(signature.params()),
            bind_list<write_method_arg>(", ", signature.params()));
    }

    static void write_java_public_method(writer& w, MethodDef const& method, TypeDef const& /*type*/)
    {
        if (is_constructor(method))
        {
            return;
        }
        
        auto format = R"(    public % %(%) {
        %abi_%%(%%);
    }

)";

        method_signature signature{ method };

        auto has_return = signature.return_signature();

        bool isStatic = is_static(method);
        w.write(format,
            bind<write_return_type_as<java_type>>(signature.return_signature()),
            java_name{ method.Name() },
            bind_list<write_param_as<java_type>>(", ", signature.params(), "% %"),
            has_return ? "return " : "",
            method.Name(),
            bind_each<write_param_type_as<java_suffix>>(signature.params()),
            isStatic ? "" : signature.params().empty() ? "abi" : "abi, ",
            bind_list<write_method_arg>(", ", signature.params()));
    }

    static void write_java_native_method(writer& w, MethodDef const& method, TypeDef const& /*type*/)
    {
        auto format = R"(    private %native % abi_%(%%);

)";

        method_signature signature{ method };
        auto methodName = is_constructor(method) ? "Construct" : method.Name();
        bool isStatic = is_static(method) || is_constructor(method);
        w.write(format,
            isStatic ? "static " : "",
            bind<write_return_type_as<java_type>>(signature.return_signature()),
            methodName,
            isStatic ? "" : "long abi, ",
            bind_list<write_param_as<java_type>>(", ", signature.params(), "% %"));
    }

    static void write_java_proxy_iterator(writer& w, std::string_view const& name_space, generic_iterator const& gi)
    {
        auto format = R"(package %;

import java.util.Iterator;

public class % extends Inspectable implements Iterator<%> {

	public %(long abi) {
		super(abi);
	}
	
	public %(Inspectable that) {
		super(that);
	}

	^@Override
	public boolean hasNext() {
		return abi_hasNext(abi);
	}

	^@Override
	public % next() {
		return abi_next(abi);
	}

    private native boolean abi_hasNext(long abi);
    private native % abi_next(long abi);
	
	private static native void Register();

	static {
		System.loadLibrary("%");
		Register();
	}
})";

        auto java_class_descriptor = gi.java_element;
        for (auto it = java_class_descriptor.begin(); it != java_class_descriptor.end(); ++it)
        {
            if (*it == '/')
            {
                *it = '.';
            }
        }

        w.write(format,
            name_space,
            gi.name,
            java_class_descriptor,
            gi.name,
            gi.name,
            java_class_descriptor,
            java_class_descriptor,

            settings.shared_lib.empty() ? name_space : settings.shared_lib);
    }

    static void write_java_proxy(writer& w, TypeDef const& type)
    {
        auto format = R"(package %;

import java.util.Iterator;

public class % extends Inspectable %
{
    public %(long abi) {
        super(abi);
    }

    public %(% that) {
        super(that);
    }

%

    ^@Override
    public boolean equals(Object arg0) {
        if (arg0 instanceof %) {
            return super.equals(arg0);
        }
        return false;
    }

%

%
    private static native void Register();

    static {
        System.loadLibrary("%");
        Register();
    }
};
        )";
        
        auto package = settings.package_base + std::string(type.TypeNamespace());
        auto library = settings.shared_lib.empty() ? package : settings.shared_lib;
        auto interfaces = get_interface_info(w, type);

        w.write(format,
            java_name{ package, java_name::lower },
            type.TypeName(),
            bind<write_java_implements>(interfaces),
            type.TypeName(),
            type.TypeName(),
            type.TypeName(),
            bind_each<write_java_constructor>(get_constructors(type), type),
            type.TypeName(),
            bind_each<write_java_public_method>(type.MethodList(), type),
            bind_each<write_java_native_method>(type.MethodList(), type),

            java_name{ library, java_name::lower }
        );
    }
}
